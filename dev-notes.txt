Run install-win to install on windows or install to install on mac (not yet up and running.)

For the future I might consider running this in a virtual environment or something but not yet.

For me the goal of the game is as such (i.e. what I'm learning): it will be a game of tute that:
* A server using sockets exists that will run the game in real time for users that are running clients
* Clients have a gui where you can click on a card to play it and so on
* It can be played from two to four players and a server where the server is on a different network from the users
* All packets sent to and from are encrypted so that the game is secure (and I practice this)
* Checkpoint game-states to a file in case of a crash (i.e. save/load games)

To make the second point work I intend to have it so that you can click to select a card and then click to move it to another spot. The cards will be alligned left to right for you on the bottom and you will see some card backs for the other players going in a circle. To keep it simple I'll have it display first on the left, then in front, then in a circle around a square table. Cards that are down you can see on the middle of the table.

To make clicking easier I have to consider whether to make this full screen and hard-code screen positions or do relative positions. I'd highly prefer relative positions if this is possible.

To make the third point I need to make a port forward script from the router. I intend to use this primarily on my Pi so I'll try to write a script if possible for automatic UPnP or something along those lines. If that's not possible then Ill just hard-code it for myself and to think about security I'll have to think about what I publish to github.

## Notes As Of May 16, 2020
I will simplify this process by making it a hard-coded port-forward and by additionally making it so that it only supports
four players.

The way the game works is the middle has three cards from left to right in three spots. Each player will have the max cards possible such that everyone has equal cards (note that this should be 12 for four players). A random suit is picked before each round. We will proceed for three games which each consists of many rounds.

I also want it to be possible to put settings for some basic rule changes in a file that you can edit.

## Update As of May 17, 2020
I'm probably going to host this on the cloud. A tutorial I sort of followed at "https://www.youtube.com/watch?v=KQasIwElg3w&list=PLzMcBGfZo4-kR7Rh-7JCVDN8lm3Utumvq&index=10" used linude and gave us some free credits potentially so I might just use linude, but AWS is also an option.

## Update As of June 5th 2020
Started working on this last night again for the first time since May 17. I am scrapping the elegant OOP of structs for now. I will make an implementation with barely any OOP, no security for sockets, and no thread safety in the code. Once I get this to work with a nice sequential game I'll add all of those things later if I feel so compelled. I just want to be able to play with Delia once So Things to fix later:

1. finish adding proper oop (make classes for player, etc.... that are actually used, pickle)
2. add checks for errors where people make mistakes (try catch and just more ifs)
3. add thread safety (locks)
4. add openSSL for some sort of RSA or diffie helman for secure transmission (openSSL or quic etc...)
5. add support for more/less than 4 players
6. add more responsivity to controls and instead of using keys control actions with mouse

# valores: as = 11, 3 = 10, rey (12) = 4, caballo (11) = 3, zeta (10) = 2
# los 40s y los 20s es cuando ganas una ronda y "cantas" un rey y un caballo del mismo palo
# (40s is mismo palo del de la ronda tambien y 20s es otro palo; pero igual tenes que ganar)
# tute es quatro reyes o quatro caballos -> ganas el juego completo

# antes de conectarse Tute tiene que mostrar:
# 1. cuantos jugadores hay
# 2. quien esta jugando

# cada junta de juegos se juegan tres juegos, pero si alguien tiene tute gana todo

# cada juego se:
# 1. se ponen jugadores a la sar al re-dedor de la mesa (la orden va a ser como un reloj)
# 2. se elige un palo a la sar (de una carta elijida a la sar)
# 3. se elije la mano a la sar 
# despues de reparten 12 cartas a cada uno
# y luego se juegan rondas hasta el fin del juego

# cada ronda se:
# 0. la mano es el que gano la mano anterior, si no se elije a la sar
# 1. la mano pone una carta elijiendo el palo
# 2. despues calquier carta puesta tiene que ser de ese palo y mas alta que la anterior
#    si no tenes mas alta que la anterior puede ser mas baja (pero tiene que ser del mismo palo)
#    si no tenes de ese palo tiene que ser del palo del juego total y ese palo tiene el valor maximo
#    si no tenes ese tampoco puede ser de cualquier palo y puede ser cualquier carta
# 3. el ganador se elige con estas reglas:
#    - de las del palo del juego gana la mas alta
#    - si no hay de ese palo, del palo de la ronda gana la mas alta
#        - siempre hay una de ese palo por que corresponde con la carta de la mano
# el que gana agarra las cuantro cartas y las pone en su pila de cartas usadas

# cosas importantes que pueda hacer el usuario:
# 1. leer sus cartas ganadas (pero no las de los otros)
# 2. tener un contador de cuantas cartas gano
# 3. tener un contador de cuantas cartas tiene
# 4. poder ver todas o casi todas sus cartas
# 5. ver las cartas del centro en el orden en que se pusieron
# 6. ver quien es la mano de la ronda

# Important notes for graphics:
# 1. each player sees themselves at the bottom
# the rest of the array from their index to the end and then around from the start to the one before them
# is filled in from left to top to right (i.e. clockwise)
# 2. whoever is playing will have their name in red, whereas everyone else will have their name in black

"""
As of June 4th 2020 we are making an MVP. This means it has to work and be the easiest implementation for me possible.
However, I intend to have graphics.

This will be the control scheme: 1-n (if you have n cards) will deploy card x if you press key x (if n is mod 10 then - then =)
On the right it will show card codes for the cards you have acquired (in text), for others it will display 
the number of cards they have acquired. It will only let you play cards that are legal (by remembering
the face and value of last one and face for the game, might actually not do this yet)
In the middle it will display all cards from LEFT TO RIGHT and decide the winner
Card codes:
type_face where face is either B (bastos), C (copas), E (espadas), or O (oros) and type is:
A for ace, R for rey, C for caballo, S for sota and numbers for the rest
players will count their points up at the end each and tell the server (this can be commandline or something)
To sing the 40s or 20s they can reveal cards to reveal cards they can press q,w,e,r,...[,] (under the numbers)
they press again to hide (they'll have to keep track of their points)

ex for cards:
A_B is the ace of bastos
R_O is the king of oros
3_E is the 3 of espadas
7_C is the 7 of copas (no vale nada)


SPACE BAR WILL BE USED TO CHANGE STATE

MVP HAS NO SECURITY CONSIDERATIONS...
IN THE FUTURE WE WILL HAVE TO ENCRYPT USING OPENSSL ETC...
"""

Yes I know that the encryption scheme is braindead and a bit busted. For a real game I'd use quic which I think is encrypted
or learn to use openSSL or something. I'm doing it this way so with a vanilla install of python it will work
(otherwise I need to get quic or openSSL or Cryptography) which might be annoying given some people are on pc, some are
on mac, and this is going to be used by people who might not be very technologically savvy.

Notes to self: don't hardcode in Droplet IP ever because it will show in logs once you make this project public. The internal IP
of my laptop inside my house is fine though (obviously because NAT).

"""
As of June 16th 2020

I am going to use the ending location of a click to determine what to do. This means that in the ButtonUp REVEAL/PLAY
part we are going to execute. This means if you click and drag you can "cancel" mistakes which is good.
"""

Yea this is badly documented I get it. The comments are literally from before I changed the design in my head.

Code I wrote by accident:

# note you never add to your cards or remove from your won cards
    def add_card_to_won(self, card):
        next_x, next_y = None, None
        offset = int(self.card_width / CARD_DENSITY)
        start_x, start_y = self.start_position

        if self.type == 'PLAYER':
            start_y -= self.real_height # your won cards display above your play cards
            next_x = len(self.won_card_sprites) * offset + start_x
            next_y = start_y
        elif self.type == 'RIGHT':
            start_x -= self.real_width # for them its on the left
            next_x = start_x
            next_y = len(self.won_card_sprites) * offset * -1 + start_y
        elif self.type == 'TOP':
            # we'll display for 'them' not for 'you'
            start_y += self.real_height # for them its on the bottom
            next_x = len(self.won_card_sprites) * offset * -1 + start_x # remember we start on the right
            next_y = start_y
        elif self.type == 'LEFT':
            start_x += self.real_width # for them its on the right (duh)
            next_x = start_x 
            next_y = len(self.won_card_sprites) * offset + start_y
        
        self.won_cards.append(card)
        self.won_card_sprites.append(
            CardSprite(card, self.real_width, self.real_height, self.rotation, next_x, next_y, self.back)
            )

    def remove_card_from_hand(self, card):
        self.cards.remove(card)
        i = 0
        while self.cards[i] != card:
            i+=1
        old = self.card_sprites.pop(i) # now i will be on the next card
        # now we need to shift all these to the left (or opposite direction lol)
        while i < len(self.card_sprites):
            # this should work no matter what type
            self.card_sprites[i].move(old.loc())
            old = self.card_sprites[i]

    # you'll be able to reveal on either and it does so by checking equality (will also hide if revealed)
    def toggle_reveal_card(self, card):
        for card_sprite in self.card_sprites:
            if card_sprite.card == card:
                card_sprite.back = not card_sprite.back
                return